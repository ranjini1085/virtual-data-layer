#!/usr/bin/python
import re


def convert_SQL_to_postgres(input_sql,
                            original_datastore_type):
    '''Converts Oracle SQL to PostgresSQL

    keyword_args:
        input_sql = the SQL statement to be converted, in text
        original_datastore_type = the datastore to be convered from
'''

    sql_tree = sql_to_tree.sql_to_tree(input_sql)
    return \
        tree_to_postgres_sql.tree_to_postgres_sql(sql_tree,
                                                  original_datastore_type)


def run_on_postgres(postgres_sql, cursor):
    '''executes query on posgresql

    keyword_args:
        postgres_sql: SQL statement formatted for PostgreSQL
        cursor: a psycopg2 cursor object

    returns:
        results of query

'''

    cursor.execute(postgres_sql)
    return cursor.fetchall()


def syntax_replace_posgres(input_token, sql_type):
    '''Converts oracle-compatible SQL tokens to postgres-compatible SQL tokens.

    keyword args:
        input_token: SQL token text
        sql_type: type of SQL system that tree was originally intended for.
            Currently supports 'Oracle'


    returns:
        SQL string with non-Postgres syntax replaced by
                                        Postgres-compatible syntax
    '''

    sql_token = input_token

    if sql_type.upper() == 'ORACLE':
        sql_token = sql_token.replace('sysdate', "'now'::timestamp")
        sql_token = sql_token.replace('nvl(', 'coalesce(')
        sql_token = sql_token.replace('rowid', 'ctid')
        sql_token = re.sub(r'(\w+)\.nextval', "nextval('\g<1>')", sql_token)

    return sql_token


def tree_to_postgres_sql(sql_tree, sql_type):
    '''Converts SQL tree to Postgres-compatible SQL.
        Does not validate that input SQL is correct.

    keyword args:
        sql_tree: SQL tree, as generated by sql_to_tree module
        sql_type: type of SQL system that tree was originally intended for.
                        Currently supports 'Oracle'


    returns:
        SQL command text string
    '''

    sql_command = ''

    # construct select block
    if len(sql_tree['select']) + len(sql_tree['select aggregate']) > 0:
        sql_command += 'select '

        select_block = sql_tree['select']
        select_block.extend(sql_tree['select aggregate'])

        for i, select_field in enumerate(select_block):

            # assemble select statment
            if 'function' in select_field.keys():
                sql_command += select_field['function']
                sql_command += '('
                if 'table_or_alias_name' in select_field.keys() \
                        and select_field['table_or_alias_name'] is not None:
                    sql_command += select_field['table_or_alias_name']
                    sql_command += '.'
                if 'column_name' in select_field.keys() \
                        and select_field['column_name'] is not None:
                    sql_command += select_field['column_name']
                else:
                    sql_command += '*'
                sql_command += ')'
            else:
                if select_field['table_or_alias_name'] is not None:
                    sql_command += select_field['table_or_alias_name']
                    sql_command += '.'
                # replace non-standard SQL parts with Postgres SQL parts
                sql_command += \
                    syntax_replace_posgres(select_field['column_name'],
                                           sql_type)

            if i < len(select_block) - 1:
                sql_command += ', '

    # construct from block
    if len(sql_tree['table_definitions']) > 0:
        sql_command += ' from '

        from_block = sql_tree['table_definitions']
        for i, table_definition in enumerate(from_block):
            if table_definition['schema'] is not None:
                sql_command += table_definition['schema']
                sql_command += '.'

            sql_command += table_definition['name']

            if table_definition['alias'] is not None:
                sql_command += ' as '
                sql_command += table_definition['alias']

            if i < len(from_block) - 1:
                sql_command += ', '

    # construct where block
    if len(sql_tree['joins']) + len(sql_tree['where_subqueries']) + \
       len(sql_tree['filters']) > 0:
        sql_command += ' where '

        # start the where block with an empty list, and then add elements
        where_block = []

        for i, v in enumerate(sql_tree['joins']):
            join = []
            join.append(v['left_identifier'] + ' = ' + v['right_identifier'])
            where_block.extend(join)

        # where_block.extend(sql_tree['where_subqueries'])

        for i, v in enumerate(sql_tree['filters']):
            filter = []
            filter.append(v['identifier'] + ' ' + v['operator'] + ' '
                          + v['value'])
            where_block.extend(filter)

        for i, where_item in enumerate(where_block):

            # replace non-standard SQL parts with Postgres SQL parts
            sql_command += syntax_replace_posgres(where_item, sql_type)

            if i < len(where_block) - 1:
                sql_command += ' and '

    # construct group by block
    if len(sql_tree['grouping']) > 0:
        sql_command += ' group by '

        groupby_block = sql_tree['grouping']

        for i, grouping in enumerate(groupby_block):
            if grouping['table_or_alias_name'] is not None:
                sql_command += grouping['table_or_alias_name']
                sql_command += '.'
            # replace non-standard SQL parts with Postgres SQL parts
            sql_command += \
                syntax_replace_posgres(grouping['column_name'],
                                       sql_type)

            if i < len(groupby_block) - 1:
                sql_command += ', '

    # construct order by block
    if len(sql_tree['ordering']) > 0:
        sql_command += ' order by '

        orderby_block = sql_tree['ordering']

        for i, ordering in enumerate(orderby_block):

            # open function block, if any
            if ordering['function'] is not None:
                sql_command += ordering['function']
                sql_command += '('

            # add table names or aliases if present
            if ordering['table_or_alias_name'] is not None:
                sql_command += ordering['table_or_alias_name']
                sql_command += '.'

            # replace non-standard SQL parts with Postgres SQL parts
            sql_command += \
                syntax_replace_posgres(ordering['column_name'],
                                       sql_type)

            # close function block, if any
            if ordering['function'] is not None:
                sql_command += ')'

            if i < len(orderby_block) - 1:
                sql_command += ', '

    # construct having block
    if len(sql_tree['having']) > 0:
        sql_command += ' having '

        having_block = sql_tree['having']

        for i, having in enumerate(having_block):
            # replace non-standard SQL parts with Postgres SQL parts
            sql_command += syntax_replace_posgres(having, sql_type)

            if i < len(having_block) - 1:
                sql_command += ', '

    # finish query
    sql_command += ';'

    return sql_command


if __name__ == '__main__':

    import sql_to_tree

    tcph3_sql = """
        select
            l_orderkey,
            sum(l_extendedprice),
            o_orderdate,
            o_shippriority
        from
            tcph.customer,
            tcph.orders,
            tcph.lineitem
        where
            c_mktsegment = 'BUILDING'
            and c_custkey = o_custkey
            and l_orderkey = o_orderkey
            and o_orderdate < '1997-12-31'
            and l_shipdate > '1998-01-01'
        group by
            l_orderkey,
            o_orderdate,
            o_shippriority
            order by
            sum(l_extendedprice),
            o_orderdate;"""

    print(tree_to_postgres_sql(sql_to_tree.sql_to_tree(tcph3_sql), 'Oracle'))
