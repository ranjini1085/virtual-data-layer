#!/usr/bin/python
#import os
#import sys
import sqlparse
import extract_table_names
import extract_selected_columns
import extract_where
import extract_orderby
import extract_aggregates
#import re

def sql_to_tree(input_sql):
    '''Converts SQL to a SQL tree.  Does not validate that input SQL is correct.

    keyword args:
        input_sql: SQL text input.  May be multiple lines, so long as they are separated by semicolon
    
    
    returns:
        list of sql tree components
    '''
#   sql_stream = extract_select_part(sqlparse.parse(sql)[0])
    
    sql_tree = {}
    
    #refactor all of these so that they take parsed SQL stream rather than raw SQL
    sql_tree['select'] = extract_selected_columns.extract_select(input_sql)
    sql_tree['select aggregate'] = extract_selected_columns.extract_select_aggregates(input_sql)
#    sql_tree['tables'] = extract_table_names.extract_tables(input_sql) can remove this function
    sql_tree['table_aliases'] = extract_table_names.extract_table_aliases(input_sql) #needs support for schemas
    sql_tree['joins'] = extract_where.extract_joins(input_sql) #needs support for outer joins
    sql_tree['filters'] = extract_where.extract_filters(input_sql)
    sql_tree['where_subqueries'] = extract_where.extract_where_subqueries(input_sql) #need to split out join from subquery
    sql_tree['grouping'] = extract_aggregates.extract_groupby(input_sql)
    sql_tree['ordering'] = extract_orderby.extract_orderby(input_sql)
    sql_tree['having'] = '' #needs to be implemented
    
    return sql_tree

def tree_to_ansi_sql(sql_tree):
    '''Converts SQL tree to SQL.  Does not validate that input SQL is correct.  Produces standard ANSI SQL

    keyword args:
        input_sql: SQL tree, as generated by sql_to_tree function
    
    
    returns:
        SQL command text string        
    '''
    
    sql_command = ''
    
    #construct select block
    if len(sql_tree['select']) + len(sql_tree['select aggregate']) > 0:
        sql_command += 'select '
    
        select_block = sql_tree['select']
        select_block.extend(sql_tree['select aggregate'])

        for i,v in enumerate(select_block):
            sql_command += v
            if i < len(select_block) - 1:
                sql_command += ', '
    
    #construct from block
    if len(sql_tree['table_aliases']) > 0:
        sql_command += ' from '
    
        from_block = sql_tree['table_aliases']
        for i, table_alias_pair in enumerate(from_block):
            sql_command += table_alias_pair[0]
            if table_alias_pair[1] != None:
                sql_command += ' as '
                sql_command += table_alias_pair[1]
                
            if i < len(from_block) - 1:
                sql_command += ', '
    
    #construct where block
    if len(sql_tree['joins']) + len(sql_tree['where_subqueries']) + len(sql_tree['filters']) > 0:
        sql_command += ' where '
    
        where_block = sql_tree['joins']
        where_block.extend(sql_tree['where_subqueries'])
        where_block.extend(sql_tree['filters'])
        
        for i, join in enumerate(where_block):
            sql_command += join
            
            if i < len(where_block) - 1:
                sql_command += ' and '
                
    #construct group by block
    if len(sql_tree['grouping']) > 0:
        sql_command += ' group by '
    
        groupby_block = sql_tree['grouping']
        
        for i, grouping in enumerate(groupby_block):
            sql_command += grouping
            
            if i < len(groupby_block) - 1:
                sql_command += ', '
            
    #construct order by block
    if len(sql_tree['ordering']) > 0:
        sql_command += ' order by '
        
        orderby_block = sql_tree['ordering']
        
        for i, ordering in enumerate(orderby_block):
            sql_command += ordering
            
            if i < len(orderby_block) - 1:
                sql_command += ', '
                
    #construct having block
    if len(sql_tree['having']) > 0:
        sql_command += ' having '
        
        having_block = sql_tree['having']
        
        for i, having in enumerate(having_block):
            sql_command += having
            
            if i < len(having_block) - 1:
                sql_command += ', '
    
    return sql_command

if __name__ == '__main__':
    input_sql = """select c.customer_name, o.order_date, sum(o.orders)
                from tcph.customer as c, tcph.order o, tcph.part
                where c.customer_id = o.customer_id
                and o.part_number = tcph.part.part_number
                and c.customer_id = 1
                group by c.customer_name, o.order_date
                order by c.customer_name;"""

    print(sql_to_tree(input_sql))
    print(tree_to_ansi_sql(sql_to_tree(input_sql)))